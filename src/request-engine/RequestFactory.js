/* eslint-disable class-methods-use-this */
import * as Events from '@advanced-rest-client/events';
import { ModulesRegistry } from '../request-modules/ModulesRegistry.js';
import ExecutionResponse from '../request-modules/ExecutionResponse.js';
import { ActionsRunner } from '../lib/actions/runner/ActionsRunner.js';
import { VariablesProcessor } from '../lib/variables/VariablesProcessor.js';

/** @typedef {import('@advanced-rest-client/events').ArcRequest.ArcEditorRequest} ArcEditorRequest */
/** @typedef {import('@advanced-rest-client/events').ArcResponse.Response} Response */
/** @typedef {import('@advanced-rest-client/events').ArcResponse.ErrorResponse} ErrorResponse */
/** @typedef {import('@advanced-rest-client/events').ArcRequest.TransportRequest} TransportRequest */
/** @typedef {import('@advanced-rest-client/events').ArcRequest.ArcBaseRequest} ArcBaseRequest */
/** @typedef {import('@advanced-rest-client/events').Variable.ARCVariable} ARCVariable */
/** @typedef {import('@advanced-rest-client/events').EnvironmentStateDetail} EnvironmentStateDetail */
/** @typedef {import('../types').EvaluateOptions} EvaluateOptions */
/** @typedef {import('../types').RegisteredRequestModule} RegisteredRequestModule */
/** @typedef {import('../types').RegisteredResponseModule} RegisteredResponseModule */
/** @typedef {import('../types').ExecutionContext} ExecutionContext */
/** @typedef {import('../types').ExecutionEvents} ExecutionEvents */
/** @typedef {import('../types').ExecutionStore} ExecutionStore */
/** @typedef {import('../types').RequestProcessOptions} RequestProcessOptions */
/** @typedef {import('../types').ResponseProcessOptions} ResponseProcessOptions */

/**
 * The class that is responsible for pre-processing and post-processing the request.
 * 
 * Pre processing part evaluates variables on the request object and then executes request plugins.
 * Post processing 
 */
export class RequestFactory {
  /**
   * 
   * @param {EventTarget} eventsTarget The reference to a DOM object that is the event target to ARC events.
   * @param {any} jexl A reference to an instance of Jexl library
   */
  constructor(eventsTarget, jexl) {
    this.eventsTarget = eventsTarget;
    this.jexl = jexl;

    this.actions = new ActionsRunner({
      jexl,
      eventsTarget,
    });

    /**
     * @type {Map<string, AbortController>}
     */
    this.abortControllers = new Map();
  }

  /**
   * Aborts the execution of the current action.
   * @param {string} id
   */
  abort(id) {
    const controller = this.abortControllers.get(id);
    if (!controller) {
      return;
    }
    controller.abort();
    this.abortControllers.delete(id);
  }

  /**
   * Takes the ARC editor request object and runs the request logic.
   * 
   * @param {ArcEditorRequest} request ARC request object generated by the request editor.
   * @param {RequestProcessOptions=} [options={}] Optional processing options.
   * @returns {Promise<ArcEditorRequest|null>} The copy of the passed request object. `null` when  the execution was aborted by any of the scripts.
   */
  async processRequest(request, options={}) {
    const copy = { ...request };
    copy.request = { ...copy.request };
    const abortController = new AbortController();
    const { signal } = abortController;
    await this.actions.processRequestActions(copy, {
      evaluateVariables: options.evaluateVariables,
      evaluateSystemVariables: options.evaluateSystemVariables,
    });

    const environment = await Events.ArcModelEvents.Environment.current(this.eventsTarget);
    const variables = this.prepareVariables(environment, options);
    if (variables.length) {
      copy.request = await this.processRequestVariables(copy.request, variables);
    }
    const modules = ModulesRegistry.get(ModulesRegistry.request);
    for (const [id, main] of modules) {
      if (signal.aborted) {
        this.abortControllers.delete(copy.id);
        return null;
      }
      // eslint-disable-next-line no-await-in-loop
      const result = await this.executeRequestModule(copy, id, /** @type RegisteredRequestModule */ (main), environment, signal);
      if (result === ExecutionResponse.ABORT) {
        return null;
      }
    }
    this.abortControllers.set(copy.id, abortController);
    return copy;
  }

  /**
   * Processes ARC transport response
   * 
   * @param {ArcEditorRequest} request ARC request object generated by the request editor.
   * @param {TransportRequest} executed The request reported by the transport library
   * @param {Response|ErrorResponse} response ARC response object.
   * @param {ResponseProcessOptions=} [options={}] Optional processing options.
   * @returns {Promise<void>} A promise resolved when actions were performed.
   */
  async processResponse(request, executed, response, options={}) {
    let abortController = this.abortControllers.get(request.id);
    if (!abortController) {
      abortController = new AbortController();
    }
    const { signal } = abortController;
    await this.actions.processResponseActions(request, executed, response, {
      evaluateVariables: options.evaluateVariables,
      evaluateSystemVariables: options.evaluateSystemVariables,
    });
    const modules = ModulesRegistry.get(ModulesRegistry.response);
    const environment = await Events.ArcModelEvents.Environment.current(this.eventsTarget);
    for (const [id, main] of modules) {
      if (signal.aborted) {
        this.abortControllers.delete(request.id);
        return;
      }
      // eslint-disable-next-line no-await-in-loop
      const result = await this.executeResponseModule(request, executed, response, id, /** @type RegisteredResponseModule */ (main), environment, signal);
      if (result === ExecutionResponse.ABORT) {
        this.abortControllers.delete(request.id);
        return;
      }
    }
    this.abortControllers.delete(request.id);
  }

  /**
   * @param {ArcEditorRequest} request ARC request object generated by the request editor.
   * @param {string} id The id of the module being executed
   * @param {RegisteredRequestModule} info The module to execute
   * @param {EnvironmentStateDetail} environment The current environment
   * @param {AbortSignal} signal The abort signal
   * @returns {Promise<number>}
   */
  async executeRequestModule(request, id, info, environment, signal) {
    const context = await this.buildExecutionContext(info.permissions, environment);
    let result;
    try {
      result = await info.fn(request, context, signal);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.warn(e);
      const message = `Request module ${id} reported error: ${e.message}`;
      throw new Error(message);
    }
    return result;
  }

  /**
   * @param {ArcEditorRequest} request ARC request object generated by the request editor.
   * @param {TransportRequest} executed The request reported by the transport library
   * @param {Response|ErrorResponse} response ARC response object.
   * @param {string} id The id of the module being executed
   * @param {RegisteredResponseModule} info The module to execute
   * @param {EnvironmentStateDetail} environment The current environment
   * @param {AbortSignal} signal The abort signal
   * @returns {Promise<number>}
   */
  async executeResponseModule(request, executed, response, id, info, environment, signal) {
    const context = await this.buildExecutionContext(info.permissions, environment);
    let result;
    try {
      result = await info.fn(request, executed, response, context, signal);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.warn(e);
      const message = `Request module ${id} reported error: ${e.message}`;
      throw new Error(message);
    }
    return result;
  }

  /**
   * Builds module execution context
   * @param {string[]} permissions 
   * @param {EnvironmentStateDetail} environment 
   * @returns {Promise<readonly ExecutionContext>}
   */
  async buildExecutionContext(permissions, environment) {
    const result = /** @type ExecutionContext */ ({
      eventsTarget: this.eventsTarget,
    });
    const hasEnvironment = permissions.includes('environment');
    if (hasEnvironment) {
      result.environment = environment;
    }
    if (permissions.includes('events')) {
      result.Events = this.prepareExecutionEvents();
    }
    if (permissions.includes('store')) {
      result.Store = this.prepareExecutionStore(hasEnvironment);
    }
    return Object.freeze(result);
  }

  /**
   * Prepares a map of events passed to the module
   * 
   * @returns {readonly ExecutionEvents}
   */
  prepareExecutionEvents() {
    const result = /** @type ExecutionEvents */ ({
      ArcNavigationEvents: Events.ArcNavigationEvents,
      SessionCookieEvents: Events.SessionCookieEvents,
      EncryptionEvents: Events.EncryptionEvents,
      GoogleDriveEvents: Events.GoogleDriveEvents,
      ProcessEvents: Events.ProcessEvents,
      WorkspaceEvents: Events.WorkspaceEvents,
      RequestEvents: Events.RequestEvents,
      AuthorizationEvents: Events.AuthorizationEvents,
      ConfigEvents: Events.ConfigEvents,
    });
    return Object.freeze(result);
  }

  /**
   * @param {boolean} hasEnvironment Whether to add environment events
   * @returns {readonly ExecutionStore}
   */
  prepareExecutionStore(hasEnvironment) {
    const result = /** @type ExecutionStore */ ({
      AuthData: Events.ArcModelEvents.AuthData,
      ClientCertificate: Events.ArcModelEvents.ClientCertificate,
      HostRules: Events.ArcModelEvents.HostRules,
      Project: Events.ArcModelEvents.Project,
      Request: Events.ArcModelEvents.Request,
      RestApi: Events.ArcModelEvents.RestApi,
      UrlHistory: Events.ArcModelEvents.UrlHistory,
      UrlIndexer: Events.ArcModelEvents.UrlIndexer,
      WSUrlHistory: Events.ArcModelEvents.WSUrlHistory,
    });
    if (hasEnvironment) {
      result.Environment = Events.ArcModelEvents.Environment;
      result.Variable = Events.ArcModelEvents.Variable;
    }
    return Object.freeze(result);
  }

  /**
   * @param {ArcBaseRequest} request
   * @param {ARCVariable[]} variables
   * @returns {Promise<ArcBaseRequest>}
   */
  async processRequestVariables(request, variables) {
    const processor = new VariablesProcessor(this.jexl, variables);
    await this.processRequestBaseVariables(processor, request);
    await this.processRequestAuthorizationVariables(processor, request);
    return request;
  }

  /**
   * @param {VariablesProcessor} processor
   * @param {ArcBaseRequest} request
   */
  async processRequestBaseVariables(processor, request) {
    const exeOptions = /** @type EvaluateOptions */ ({
      names: ['url', 'headers', 'method', 'payload'],
    });
    try {
      await processor.evaluateVariables(request, exeOptions);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(`Unable to process variables. Continuing without processing.`);
      // eslint-disable-next-line no-console
      console.error(e);
    }
  }

  /**
   * @param {VariablesProcessor} processor
   * @param {ArcBaseRequest} request
   */
  async processRequestAuthorizationVariables(processor, request) {
    if (!Array.isArray(request.authorization) || !request.authorization.length) {
      return;
    }
    const authorization = [...request.authorization];
    const ps = authorization.map(async (auth, i) => {
      const copy = { ...auth };
      const { enabled, config } = copy;
      if (enabled === false) {
        return;
      }
      const cnfCopy = { ...config };
      copy.config = cnfCopy;
      try {
        await processor.evaluateVariables(cnfCopy);
        authorization[i] = copy;
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error(`Unable to process variables for authorization. Continuing without processing.`);
        // eslint-disable-next-line no-console
        console.error(e);
      }
    });
    await Promise.all(ps);
    request.authorization = authorization;
  }

  /**
   * @param {EnvironmentStateDetail} environment
   * @param {RequestProcessOptions=} options
   * @returns {ARCVariable[]}
   */
  prepareVariables(environment, options={}) {
    if (options.evaluateVariables === false) {
      return [];
    }
    const { variables=[], systemVariables } = environment;
    if (options.evaluateSystemVariables !== false && systemVariables) {
      Object.keys(systemVariables).forEach((name) => {
        const item = /** @type ARCVariable */ ({
          name,
          value: systemVariables[name],
          enabled: true,
          environment: 'any',
        });
        variables.push(item);
      });
    }
    return variables;
  }
}
